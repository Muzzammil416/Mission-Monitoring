#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <algorithm> 
#include <fstream>   
#include <stdlib.h>
#include <conio.h> 
#include <ctime>    
using namespace std;

// Structure to represent a date
struct Date
{
    int day;
    int month;
    int year;
};

class Interface
{
protected:
    string password;
    string username;
    map<string, string> credentials; // Dataset to store usernames and passwords
    string choice;
    string name;
    string newpassword;
    string confirmpassword;

public:
    // Function to read usernames and passwords from file
    void readCredentialsFromFile(const string &filename)
    {
        ifstream file(filename);
        if (file.is_open())
        {
            string line;
            while (getline(file, line))
            {
                size_t pos = line.find(":");
                if (pos != string::npos)
                {
                    string user = line.substr(0, pos);
                    string pass = line.substr(pos + 1);
                    credentials[user] = pass;
                }
            }
            file.close();
        }
    }

    // Function to write usernames and passwords to file
    void writeCredentialsToFile(const string &filename)
    {
        ofstream file(filename);
        if (file.is_open())
        {
            for (const auto &cred : credentials)
            {
                file << cred.first << ":" << cred.second << "\n";
            }
            file.close();
        }
    }

class Goal
{
private:
    string name;
    double targetAmount;
    double currentAmount;
    Date startDate;
    Date endDate;
    string reason;
    vector<pair<string, double>> miniGoals;
    vector<double> dailyProgress; // Store daily progress
    double dailyGoal;             // Daily goal amount
    vector<Date> completionDates;
public:
    Goal() {}
    // Constructor
    Goal(string n, double target, double start, Date sDate, Date eDate, double daily)
        : name(n), targetAmount(target), currentAmount(start),
          startDate(sDate), endDate(eDate), dailyGoal(daily) {}

    // Getter methods
    string getName() const { return name; }
    double getTargetAmount() const { return targetAmount; }
    double getCurrentAmount() const { return currentAmount; }
    Date getStartDate() const { return startDate; }
    Date getEndDate() const { return endDate; }
    string getReason() const { return reason; }
    bool hasReasonSet() const { return !reason.empty(); }
void markAsCompleted(const Date &completionDate)
    {
        completionDates.push_back(completionDate);
    }

    // Function to display completion dates
    void displayCompletionDates() const
    {
        if (completionDates.empty())
        {
            cout << "Goal has not been completed yet.\n";
            return;
        }
        cout << "Completion Dates:\n";
        for (const auto &date : completionDates)
        {
            cout << date.day << "/" << date.month << "/" << date.year << endl;
        }
    }


class GoalTracker
{
private:
    vector<Goal> goals;
    vector<Goal> completedGoals; // Store completed goals permanently
    vector<vector<int>> pointsMatrix; // Matrix to store points for each goal
        
         void writeGoalToFile(const Goal &goal, ofstream &file) const
    {
        goal.writeToStream(file);
        file << "\n"; // Add separator between goals
        goal.writeCompletionDatesToFile(file); // Write completion dates
        file << "\n"; // Add separator between goals
    }

     void readGoalFromFile(Goal &goal, ifstream &file)
    {
        // Existing code...
        goal.readCompletionDatesFromFile(file); // Read completion dates
    }
  void addCompletedGoal(const Goal &goal)
    {
        completedGoals.push_back(goal);
    }

    // Function to write completed goals to file
    void writeCompletedGoalsToFile(const string &filename) const
    {
        ofstream file(filename);
        if (file.is_open())
        {
            for (const auto &goal : completedGoals)
            {
                writeGoalToFile(goal, file);
            }
            file.close();
        }
        else
        {
            cerr << "Unable to open file: " << filename << endl;
        }
    }

