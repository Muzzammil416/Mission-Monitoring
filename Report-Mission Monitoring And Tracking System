#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <algorithm> 
#include <fstream>   
#include <stdlib.h>
#include <conio.h> 
#include <ctime>    
using namespace std;

// Structure to represent a date
struct Date
{
    int day;
    int month;
    int year;
};

class Interface
{
protected:
    string password;
    string username;
    map<string, string> credentials; // Dataset to store usernames and passwords
    string choice;
    string name;
    string newpassword;
    string confirmpassword;

public:
    // Function to read usernames and passwords from file
    void readCredentialsFromFile(const string &filename)
    {
        ifstream file(filename);
        if (file.is_open())
        {
            string line;
            while (getline(file, line))
            {
                size_t pos = line.find(":");
                if (pos != string::npos)
                {
                    string user = line.substr(0, pos);
                    string pass = line.substr(pos + 1);
                    credentials[user] = pass;
                }
            }
            file.close();
        }
    }

    // Function to write usernames and passwords to file
    void writeCredentialsToFile(const string &filename)
    {
        ofstream file(filename);
        if (file.is_open())
        {
            for (const auto &cred : credentials)
            {
                file << cred.first << ":" << cred.second << "\n";
            }
            file.close();
        }
    }
void inputsr()
    {
        cout << "\n\t\t\t\t\t\t      MAQSAD" << endl;
        cout << "\t\t\t\t\tLogin\t\tor\t\tRegister" << endl;
        getline(cin, choice);
        system("cls");
        if (choice == "login" || choice == "Login")
        {
            inputsl();
        }
        else if (choice == "register" || choice == "Register")
        {
            regis();
        }
        else
        {
            cout << "Invalid choice. Please try again." << endl;
            inputsr();
        }
    }

    void regis()
    {
        system("cls");
        cout << "\t\t\t\t\t\tMAQSAD REGISTRATION PAGE" << endl;
        cout << endl
             << endl
             << endl;
        cout << "\t\t\t\t\t\tName" << endl;
        cout << "\t\t\t\t\t\t";
        getline(cin, username);
        cout << endl
             << endl
             << endl;
        cout << "\t\t\t\t\t\t New Password" << endl;
        cout << "\t\t\t\t\t\t";
        getline(cin, newpassword);
        cout << endl
             << endl
             << endl;
        cout << "\t\t\t\t\t\t Confirm Password" << endl;
        cout << "\t\t\t\t\t\t";
        getline(cin, confirmpassword);

        if (newpassword == confirmpassword)
        {
            cout << endl
                 << "Passwords match. Registration successful!" << endl;
            credentials[username] = newpassword;
            inputsl(); // Store username and password in the dataset
        }
        else
        {
            cout << endl
                 << "Passwords do not match. Please try again." << endl;
            regis(); // If passwords do not match, prompt for registration again
        }

        cout << endl;
    }

class Goal
{
private:
    string name;
    double targetAmount;
    double currentAmount;
    Date startDate;
    Date endDate;
    string reason;
    vector<pair<string, double>> miniGoals;
    vector<double> dailyProgress; // Store daily progress
    double dailyGoal;             // Daily goal amount
    vector<Date> completionDates;
public:
    Goal() {}
    // Constructor
    Goal(string n, double target, double start, Date sDate, Date eDate, double daily)
        : name(n), targetAmount(target), currentAmount(start),
          startDate(sDate), endDate(eDate), dailyGoal(daily) {}

    // Getter methods
    string getName() const { return name; }
    double getTargetAmount() const { return targetAmount; }
    double getCurrentAmount() const { return currentAmount; }
    Date getStartDate() const { return startDate; }
    Date getEndDate() const { return endDate; }
    string getReason() const { return reason; }
    bool hasReasonSet() const { return !reason.empty(); }
void markAsCompleted(const Date &completionDate)
    {
        completionDates.push_back(completionDate);
    }

    // Function to display completion dates
    void displayCompletionDates() const
    {
        if (completionDates.empty())
        {
            cout << "Goal has not been completed yet.\n";
            return;
        }
        cout << "Completion Dates:\n";
        for (const auto &date : completionDates)
        {
            cout << date.day << "/" << date.month << "/" << date.year << endl;
        }
    }
// Function to write completion dates to file
    void writeCompletionDatesToFile(ofstream &file) const
    {
        file << completionDates.size() << "\n";
        for (const auto &date : completionDates)
        {
            file << date.day << " " << date.month << " " << date.year << "\n";
        }
    }

    // Function to read completion dates from file
    void readCompletionDatesFromFile(ifstream &file)
    {
        int numCompletionDates;
        file >> numCompletionDates;
        for (int i = 0; i < numCompletionDates; ++i)
        {
            Date completionDate;
            file >> completionDate.day >> completionDate.month >> completionDate.year;
            completionDates.push_back(completionDate);
        }
    }
    // Function to update progress
    void updateProgress(double amount)
    {
        currentAmount += amount;
        dailyProgress.push_back(amount); // Add daily progress
    }

    // Function to add a reason for the goal
    void setReason(const string &r)
    {
        reason = r;
    }

    // Function to add a mini goal
    void addMiniGoal(const string &description, double targetAmount)
    {
        miniGoals.push_back(make_pair(description, targetAmount));
    }

    // Function to display mini goals
    void displayMiniGoals() const
    {
        if (miniGoals.empty())
        {
            cout << "No mini goals set for this goal.\n";
            return;
        }
        cout << "Mini Goals:\n";
        for (const auto &goal : miniGoals)
        {
            cout << "Description: " << goal.first << ", Target: $" << goal.second << endl;
        }
    }

    // Function to display daily progress
    void displayDailyProgress() const
    {
        cout << "Daily Progress:\n";
        if (dailyProgress.empty())
        {
            cout << "No progress recorded yet.\n";
            return;
        }
        int day = 1;
        for (const auto &progress : dailyProgress)
        {
            cout << "Day " << day++ << ": $" << progress << endl;
        }
    }

    // Function to calculate percentage completion
    double percentageCompletion() const
    {
        return (currentAmount / targetAmount) * 100;
    }

    // Function to check if daily goal is met
    bool isDailyGoalMet() const
    {
        if (dailyProgress.empty())
            return false;

        double totalDailyProgress = 0.0;
        for (const auto &progress : dailyProgress)
        {
            totalDailyProgress += progress;
        }

        return totalDailyProgress >= dailyGoal;
    }

    // Function to write the goal to file
    void writeToStream(ofstream &file) const
    {
        file << name << "\n";
        file << targetAmount << "\n";
        file << currentAmount << "\n";
        file << startDate.day << " " << startDate.month << " " << startDate.year << "\n";
        file << endDate.day << " " << endDate.month << " " << endDate.year << "\n";
        file << reason << "\n";
        file << miniGoals.size() << "\n";
        for (const auto &goal : miniGoals)
        {
            file << goal.first << " " << goal.second << "\n";
        }
        file << dailyProgress.size() << "\n";
        for (const auto &progress : dailyProgress)
        {
            file << progress << "\n";
        }
        file << dailyGoal << "\n";
    }

    // Function to read the goal from file
    void readFromStream(ifstream &file)
    {
        getline(file, name);
        file >> targetAmount;
        file >> currentAmount;
        file >> startDate.day >> startDate.month >> startDate.year;
        file >> endDate.day >> endDate.month >> endDate.year;
        file.ignore(); // Ignore newline character
        getline(file, reason);
        int numMiniGoals;
        file >> numMiniGoals;
        file.ignore(); // Ignore newline character
        for (int i = 0; i < numMiniGoals; ++i)
        {
            string description;
            double target;
            file >> description >> target;
            miniGoals.push_back(make_pair(description, target));
        }
        int numDailyProgress;
        file >> numDailyProgress;
        file.ignore(); // Ignore newline character
        for (int i = 0; i < numDailyProgress; ++i)
        {
            double progress;
            file >> progress;
            dailyProgress.push_back(progress);
        }
        file >> dailyGoal;

    }
};


class GoalTracker
{
private:
    vector<Goal> goals;
    vector<Goal> completedGoals; // Store completed goals permanently
    vector<vector<int>> pointsMatrix; // Matrix to store points for each goal
        
         void writeGoalToFile(const Goal &goal, ofstream &file) const
    {
        goal.writeToStream(file);
        file << "\n"; // Add separator between goals
        goal.writeCompletionDatesToFile(file); // Write completion dates
        file << "\n"; // Add separator between goals
    }

     void readGoalFromFile(Goal &goal, ifstream &file)
    {
        // Existing code...
        goal.readCompletionDatesFromFile(file); // Read completion dates
    }
  void addCompletedGoal(const Goal &goal)
    {
        completedGoals.push_back(goal);
    }

    // Function to write completed goals to file
    void writeCompletedGoalsToFile(const string &filename) const
    {
        ofstream file(filename);
        if (file.is_open())
        {
            for (const auto &goal : completedGoals)
            {
                writeGoalToFile(goal, file);
            }
            file.close();
        }
        else
        {
            cerr << "Unable to open file: " << filename << endl;
        }
    }
// Function to read completed goals from file
    void readCompletedGoalsFromFile(const string &filename)
    {
        ifstream file(filename);
        if (file.is_open())
        {
            while (!file.eof())
            {
                Goal goal;
                goal.readFromStream(file);
                if (!file.eof())
                {
                    completedGoals.push_back(goal);
                }
            }
            file.close();
        }
        else
        {
            cerr << "Unable to open file: " << filename << endl;
        }
    }

public:
	
	GoalTracker operator+(const vector<vector<int>> &points) const
    {
        GoalTracker result(*this);
        for (size_t i = 0; i < points.size(); ++i)
        {
            for (size_t j = 0; j < points[i].size(); ++j)
            {
                if (i < result.pointsMatrix.size() && j < result.pointsMatrix[i].size())
                {
                    result.pointsMatrix[i][j] += points[i][j];
                }
            }
        }
        return result;
    }
    // Function to add a new goal
    void addGoal(const string &name, double targetAmount, double startingAmount, Date startDate, Date endDate, double dailyGoal)
    {
        goals.emplace_back(name, targetAmount, startingAmount, startDate, endDate, dailyGoal);
        // Initialize a row for the new goal in the points matrix
        pointsMatrix.push_back(vector<int>());
         writeGoalsToFile("goals.txt");
        cout << "Goal added successfully!\n";
    }
